\section{Introduction}
\label{sec:intro}

\acs{https} is fundamental for secure Web communication. When a user Alice
wishes to securely access Bob's site \texttt{bob.com}, \ac{https} allows Bob to
serve his site over a secure communication channel that provides secrecy and
integrity. To establish this channel, Alice and Bob perform the \ac{tls}
handshake protocol~\cite{rfc5246}, which allows Bob to use his public key
$\pk_B$ to establish a shared secret key with Alice, which they can subsequently
use for encrypted communication.

To convince Alice that $\pk_B$ should be associated with \texttt{bob.com},
however, \ac{https} relies on the Web \ac{pki}. A trusted third party called a
\emph{\ac{ca}} checks that Bob owns both \texttt{bob.com} and the private key
corresponding to $\pk_B$, and
issues a digitally signed certificate that vouches for this binding. \acp{ca}
thus play a crucial role in secure Web communication: the failure of any \ac{ca}
due to error, compromise, or coercion can lead to a certificate that binds
\texttt{bob.com} to a different public key $\pk_M$. If for example this key
belongs to an adversary Mallory, she can impersonate Bob to Alice in a
\emph{\ac{mitm} attack}, one of the main problems that \iac{pki} aims to solve.

Unfortunately, the current Web \ac{pki} is demonstrably fragile. Existing
certificate databases indicate that Web browsers and operating systems provided
by Mozilla, Apple, and Microsoft directly or indirectly trust more than 1,500
\ac{ca} signing keys across more than 600 organizations worldwide. There are few
measures in place to prevent any of these \acp{ca} from issuing an unauthorized
certificate for any site, resulting in \emph{weakest-link security} for most
sites: the compromise of any \ac{ca} can threaten the security of all Web
domains, and by extension, all clients visiting sites on those domains. Recent
years have seen a plethora of incidents where misbehaving \acp{ca} issued
unauthorized certificates, both accidentally~\cite{sleevi2015sustaining} and
intentionally~\cite{valsorda2015komodia}.

As we describe in \autoref{sec:background}, previous work has made progress
towards protecting clients and domains against the misbehavior of trusted
entities such as \acp{ca}, and some of this work has seen increasingly
widespread deployment. Unfortunately, no proposed solution offers both
preemptive, robust protection against misbehaving \acp{ca} and a feasible,
secure deployment strategy. In particular, while systems like Google's \ac{ct}
project~\cite{rfc6962} enjoy relatively widespread deployment, they only enable
detection, not prevention, of unauthorized certificate issuance. Systems that do
prevent unauthorized certificate issuance add new trusted
parties~\cite{kim2013accountable}, require domains to deploy complex new
infrastructure~\cite{rfc6698, szalachowski2014policert}, significantly increase
latency and communication~\cite{yu2016dtki}, or require all domains to increase
their security level at once~\cite{basin2014arpki}. Many of these systems also
require \acp{ca} to drastically change their operational processes or require
domains to undergo a complex and error-prone deployment process in which
mistakes are difficult to fix. For example, public-key pinning~\cite{rfc7469}
had many misconfigurations that rendered domains inaccessible; as a result,
Google recently decided to remove support for it~\cite{palmer2017intent}.

To address these shortcomings, we propose \ac{name}, a system that provides a
modest roadmap for transitioning to a more resilient Web \ac{pki}. In \ac{name},
domains can take simple steps to protect themselves from \ac{mitm} attacks in
the presence of one or more misbehaving \acp{ca}. Furthermore, \ac{name} offers
an incremental  deployment strategy free of the perils experienced in previous
work: the interaction between domains and \acp{ca} remains fundamentally the
same, and clients are protected from downgrade attacks such as \ac{tls}
stripping~\cite{marlinspike2009new} during deployment. In \ac{name}, the
existing \ac{pki} can coexist with one that offers stronger security guarantees,
allowing domains to decide when they are ready to improve their own security
without penalizing non-deployers. The bulk of the deployment effort of \ac{name}
can occur at a small handful of participants, namely browser vendors and public
logs, who are better equipped to make these changes than domains or \acp{ca}
that have historically been reluctant to deploy major changes.

\ac{name} achieves the above properties through several important observations.
First, because the Web \ac{pki} encompasses a vast set of domains with diverse
security needs, few changes to the \ac{pki} will be universally adopted
overnight. Thus we must have a \emph{signaling mechanism} to indicate which
domains have adopted a new \ac{pki} enhancement. In part, we convey this signal
with the use of a single bit that indicates whether a domain supports
\ac{https}. Without this bit \ac{tls} stripping~\cite{marlinspike2009new} can
occur, causing the client to ignore even the existing \ac{pki}. With the use of
this bit, the remaining signaling information can be communicated as an
extension to the \ac{tls} handshake. Because existing solutions for indicating
\ac{https} deployment require the client to trust its first connection to the
domain, they have lagged in deployment~\cite{rfc4033, rfc6698}, and add
significant storage overhead\endnote{\url{https://www.eff.org/https-everywhere}}
or connection
latency.\endnote{\url{https://mybrowseraddon.com/smart-https.html}} Instead, we
use data compression techniques and compact data structures to locally store at
each client a succinct summary of the \emph{entire} set of domains that deploy
\ac{https}; with our techniques, it requires less than 200 MB.

We also observe that all known instances of \ac{ca} misbehavior up to this point
have involved a single misbehaving \ac{ca}.  Hence, \ac{name} allows a domain to
authenticate its public key using multiple independent certificate chains (we
quantify the impact this has on connection latency and bandwidth in
Section~\ref{sec:evaluation}). \ac{name}-enabled clients know how many chains to
expect for each domain, and hence, the simultaneous failure of $n-1$ \acp{ca}
cannot enable \iac{mitm} attack on a domain with $n$ chains. Note that \ac{name}
signals to clients the \emph{number} of certificate chains to expect, rather
than the list of authorized \acp{ca}.  This results in a useful practical
property: misconfiguration or private key loss cannot render a domain
inaccessible, since the domain can simply obtain the requisite number of
certificates to establish a new authoritative public key.

To vouch for the number of certificate chains that a client should expect to
receive, \ac{name} uses publicly auditable authenticated database services based
on a global view of all certificates in the Web \ac{pki}, which allows us to
\emph{automatically} infer the number of certificate chains for each domain.
Previous work has shown that such a global view can be valuable in understanding
and improving the Web \ac{pki}~\cite{durumeric2015search, larisch2017crlite}.
% \steve{Cite the certificate linting paper too}

Finally, we observe that such a strongly authenticated, authoritative public key
for a domain is a powerful force: it can be used on its own to provide greater
confidence in a site's identity, or it can be used to authenticate richer
policies as proposed in prior work~\cite{basin2014arpki,
szalachowski2014policert}. \ac{name} can thus simplify the deployment of these
proposed systems, whose existing deployment and certificate issuance strategies
rely on complex coordination among domains, \acp{ca}, and public logs to certify
these policies. \ac{name} also enhances the recoverability of these systems,
which, as originally proposed, require waiting for days to replace a policy if
the corresponding private key is lost or compromised.

Even without considering wholly new \acp{pki}, \ac{name} is attractive from a
deployment standpoint. In particular, the administrative burden of deployment
for domains is limited to purchasing additional certificates, and with the use
of free certificate services like Let's
Encrypt,\endnote{\url{https://letsencrypt.org/}} the financial burden can be
minimized as well. Furthermore, \ac{name} is an opt-in system, meaning that only
domains who choose to obtain additional certificates incur a cost. From its
initial deployment, \ac{name} protects all domains from \ac{tls} stripping, and
it allows non-deploying domains to coexist with deploying domains without
enabling downgrade attacks.

In summary, we make the following contributions:
\begin{compactitem}
\item We show how we can use a global, near-complete view of certificates in the
  Web \ac{pki}, as well as techniques from data compression and compact data
  structures to succinctly represent the set of \emph{all} domains that serve
  \ac{https} requests.
\item We show how using the global view of certificates, along with the above
  set and an authenticated database service, can be used to communicate the
  maximum number of independent certificate chains observed for each domain in a
  way that prevents \ac{tls} stripping and downgrade attacks while avoiding the
  pitfalls of key pinning.
\item We show that the above, which comprises \ac{name}, can be implemented in a
  backwards-compatible way and be used to smoothly and securely transition to a
  more resilient Web \ac{pki}.
\item We demonstrate through an evaluation that the client-side overhead for
  \ac{name} in terms of storage, memory, and connection establishment latency is
  modest for the vast majority of use cases.
\end{compactitem}

