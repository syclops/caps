\section{Introduction}
\label{sec:intro}

%Some questions to think about:
%\begin{compactitem}
%\item How can we move toward a world in which domains use multiple independent
  %certificate chains?
%\item How do we validate a self-signed certificate?
%\item What does it mean to have trust agility?
%\item Does the use of multiple independent certificate chains provide better
  %security and agility?
%\end{compactitem}

%  Proposed Outline
%
%  - HTTPS fundamental for secure web communication (cite pervasiveness stats)
%    - TLS creates a channel with secrecy and integrity
%    - But it relies on CAs to bind keys to identities and hence provide authentication
%
%  - Current PKI is fragile
%    - Trusts over 1200 CAs    //, which creates a lot of options for weakest link
%    - A failure of any weakest link (i.e., one CA) can threaten the security of all clients and all domains
%    - Unfortunately, being human endeavours, CAs fail at their jobs with depressing regularity 
%      // these CAs are demonstrably unreliable
%
%  - As we discuss in Section 2, prior work is insufficient
%    - Either 
%      - Settles for detecting, rather than preventing harm
%      - Or requires flag-day upgrade, increased latency, new trusted parties, 
%        new complex infrastructure, or unincentivized behavior from existing parties
%
%  - In contrast, we propose a modest roadmap for bootstraping a more resilient PKI,
%    where the failure of a single trusted entity cannot subvert secure communication
%    - Summary here
%      - Use a single bit to convey TLS deployment
%      - Use info embedded in the TLS handshake to convey how many cert chains 
%        should be used to authenticate a domain's public key
%      - Leverage strongly authenticated keys to authorize richer policies
%    - Or maybe high-level goals?
%      - A design that focuses the necessary changes on a small handful of motivated participants
%      - A design where domains need only take action if they want to opt into a more resilient PKI
%      - A design that imposes minimal latency, and only on those domains that opt in
%      - Ultimately allows the Internet to slowly ratchet up security to an appropriate level,
%        increasing security while simplifying deployment
%      - \name accomplishes these goals by harnessing several key observations
%
%  - First, we observe that few changes to the PKI (including any we propose) are likely to be universally adopted overnight.  
%  - The PKI serves a diverse set of domains with a correspondingly diverse set of security needs
%  => We need a _signaling_ mechanism to indicate, for a given domain, what security enhancements
%     it has adopted
%     - Such a signaling mechanism must inherently be extrinsic to the PKI itself
%       - b/c within the PKI, a client can't distinguish a domain that hasn't opted in
%         from an attacker subverting a connection to a domain that has
%
%  - With \name, we show that a single bit suffices to bootstrap resiliency
%    - We need one bit to signal whether a domain employs TLS
%    - Without that bit, client is subject either to TLS stripping, or to the latency
%      of an interactive query to an external service
%      - Browser vendors are unlikely to impose such latency on all HTTP sites,
%        even for the sake of improved security
%    - With that bit, we can convey all remaining policy information during the TLS handshake
%
%    - While DNS and DNSSEC seem appealing, due to limitations we discuss in Section 2,
%      we opt to signal via browser vendors
%      - We design succinct data structures to allow browser vendors to embed and update
%        this knowledge in their clients
%
%  - Having established that a domain deploys TLS, how do we provide increased resilience?
%    - Rather than immediately pushing a rich (baroque?) policy language,
%      we explore a modest and yet effective step:
%      - The core of our proposal is simple: A domain obtains multiple independent certificate
%        chains for its public key and presents them to the client during the TLS handshake
%        - Rise of services like Let's Encrypt make it feasible to acquire multiple certs
%      - Only the simultaneous failure of K CAs can subvert this arrangement
%        - This has never(?) happened, despite X individual failures in Y years
%
%  - We will leverage the imminent ubiquity of CT to convey to clients how many chains to expect
%    - Chrome will imminently require the use of CT for TLS-enabled websites
%    - Explain CT and what it means for it to be required
%
%  - We leverage ubiquitous CT in two ways:
%    - First, it creates a definitive catalog of domains that deploy TLS
%    - Second, we augment the CT logs with functionality to track how many 
%      independent chains they see for a domain.  This count is then embedded
%      in CT proofs provided to domains and hence to clients
%
%    - Hence, when a domain obtains one cert chain, it is automatically protected from TLS stripping
%    - When it obtains and deploys a second independent chain, CT logs observe this,
%      and convey to clients that they should only authenticate the domain when they see two indepdent chains
%      - Hence domain is now protected from the failure of any one CA
%      - Further increases possible for sites with more security concerns
%    - Section 3 delves into the subtleties of how to cope with cert renewal,
%      cert revocation, key compromise, and domains that change to a new CA
%        
%  - Once a domain has a public key authenticated with multiple independent 
%    certificate chains, it can use the corresponding private key to sign more complex
%    policies that can live in the CT logs, a la PoliCert, ARPKey, etc.
%
%  - From a deployment standpoint, simplicity is a virtue
%    - Existing mechanisms for obtaining a certificate remain the same
%    - Server code offering certs and client code validating it remains (almost?) the same
%    - By default, domains need make no changes and yet can already benefit from anti-TLS stripping
%      - Non-TLS make no changes and suffer no performance penalties
%    - Motivated domains can increase their level of resilience to whatever level they desire
%    - Bulk of the changes concentrated on handful of browser vendors and handful of CT logs
%
%  - Summarize evaluation results
%

\acs{https}, built on \ac{tls}~\cite{rfc5246} and the Web \ac{pki}, lies at the
heart of secure end-to-end communication on the Web. \Acp{ca}, who vouch for the
binding between a domain's name and its public key, play a critical role in the
Web \ac{pki}. \Iac{ca}'s failure to correctly sign this binding in the form of a
public key certificate can lead to \iac{mitm} attack, allowing an adversary to
intercept and modify all communication between a client and domain. Recent years
have seen a plethora of these failures, both
accidental~\cite{sleevi2015sustaining} and
intentional~\cite{valsorda2015komodia}.

The failures of \acp{ca} continually remind us of the weakest-link security of
the Web \ac{pki}: out of over 1,200 trusted \acp{ca}, a single misbehaving
\ac{ca} can expose a domain to \ac{mitm} attacks. Because we cannot prevent
\acp{ca} from misissuing certificates, protecting clients from these \ac{mitm}
attacks entails ensuring that clients do not accept misissued certificates. In
order to prevent clients from accepting misissued certificates, domains must
provide information that clients can use to determine which certificates to
accept. We can think of this information as a certificate policy of sorts, and
consider the following problem, which we call \emph{certificate policy
specification}: how can we use policy information to move away from a
weakest-link secure \ac{pki}?

Previous proposals (\autoref{sec:background:policy} have addressed this problem
by introducing additional trusted parties~\cite{kim2013accountable} or requiring
all domains to increase their level of security at once~\cite{basin2014arpki},
both of which require significant work to deploy. Moreover, these proposals all
provide a general policy framework and thereby involve the domain at each step
of policy creation and maintenance. Even if the domain specifies a simple
policy, such as a list of trusted \acp{ca}, it must explicitly provide this
information. This requirement means that domains need to be closely involved
even at the initial stages of adoption, thus hindering deployability. In
considering the certificate policy specification problem, we therefore seek a
solution that minimizes domain involvement.

%So far, proposed systems for communicating policy information to clients have
%not gained traction in practice. These systems introduce additional trusted
%parties~\cite{kim2013accountable} or assume that the entire Web will increase
%its security at once~\cite{basin2014arpki}. These shortcomings motivate the
%problem of designing a simple and deployable policy mechanism that requires
%minimal effort from domains. \steve{The last part isn't motivated well; it would
  %be nice if we could show that most policies are overkill for preventing
%\ac{mitm} attacks that could have resulted from recent \ac{ca} failures.}


%The Web's \ac{pki} enables client browsers to authenticate the public keys of
%the domains they communicate with, and together with the \ac{tls}
%protocol~\cite{rfc5246} allows a client and domain to establish an end-to-end
%secure communication channel through \acs{https}. In the Web \ac{pki},
%trusted third parties called \emph{\acp{ca}} vouch for the binding between a
%domain's name and its public key. The correct operation of \acp{ca} are critical
%to the security of the Web \ac{pki}, and failures can lead to the client
%establishing a secure channel with the wrong domain. In some cases this
%scenario can lead to a \emph{\ac{mitm} attack}, in which even though the
%confidentiality and integrity guarantees of communication over \ac{tls} hold,
%they provide no benefit because an adversary is impersonating the client and
%domain to each other and can read and modify all communication between them.

%While there are many proposals (enumerated in \autoref{sec:related}) to fix the
%Web \ac{pki} by deterring, preventing, or recovering from \ac{ca} misbehavior,
%Google's \emph{\ac{ct}} system~\cite{rfc6962} has recently emerged as a widely
%deployed example of such a system, being scheduled for full deployment in
%October 2017. \ac{ct} does not prevent \ac{mitm} attacks, but rather enables
%widespread detection of \ac{ca} misbehavior. In \ac{ct}, a set of \emph{public
%logs} maintain a database of certificates they have observed (primarily sent to
%them by the \acp{ca} themselves) and provide cryptographic proofs called
%\emph{\acp{sct}} that show when these certificates were submitted to the log.
%Clients do not accept certificates unless they are sent with a requisite number
%of these \acp{sct}, ensuring that an adversary cannot use an unauthorized
%certificate for \ac{mitm} attacks without first exposing that certificate to the
%world.

%However, \ac{ct} has several notable shortcomings. \ac{ct} does not make
%\ac{mitm} attack prevention an explicit goal, but specifies the behavior of
%\emph{monitors}, who periodically download newly logged certificates and check
%for suspicious certificates. However, only domains know which certificates they
%have authorized, and \ac{ct} does not allow domains to check logs for
%certificates issued in their name. This disparity means that some manual effort,
%on the part of the monitors, domains, or both, is required to prevent \ac{mitm}
%attacks that result from unauthorized certificates. Both monitors and domains
%face hurdles due to this manual effort.

%With the increasing deployment of \ac{https} through certificate services such
%as Let's Encrypt,\footnote{\texttt{https://letsencrypt.org/}} monitors may not
%be able to keep up with the number of suspicious certificates that require
%further manual investigation. Previous work enables domains to alleviate this
%pressure on monitors by explicitly supplying \emph{policies} that specify
%criteria that a domain's certificates should meet, but it is not clear that the
%expressiveness of these policies and the burden they impose on domain operators
%is worth the benefit of protecting them from common certificate misissuances. We
%therefore seek a simpler, more automated system for specifying certificate
%policies through the \ac{ct} infrastructure. In particular, we aim to move
%towards \iac{pki} in which one-off mistakes by \acp{ca} do not expose domains to
%\ac{mitm} attacks.

Unfortunately, even with such policies, we still fall short of a truly secure
\ac{pki}. Domains may not only have different policies, but some domains may not
have policies at all because they do not deploy \ac{https}. Therefore, an
adversary can carry out a \emph{\ac{tls} stripping} attack, in which the
adversary convinces the client and domain to communicate over plain HTTP rather
than over \ac{https}. Because we realistically expect a world of partial
deployment in which the set of deploying domains increases incrementally over
time, in order to prevent \ac{tls} stripping, we need a mechanism to inform
clients \emph{when} to expect a certificate policy, not just \emph{what} policy
to expect. We thus consider the following problem, which we call
\emph{\ac{https} signaling}: how can we communicate to all clients the set of
domains from which they should expect \iac{tls} certificate and certificate
policy?

Previous proposals (\autoref{sec:background:signaling}) have addressed this
problem by requiring expensive online checks \steve{Smart HTTPS}, requiring
domains to deploy DNSSEC~\cite{rfc6698}, or providing an incomplete view of the
domains signaling \ac{https} deployment \steve{HTTPS Everywhere, HSTS
preloading}. These approaches incur significant latency, are
configuration-intensive and error-prone, or have limited scope. Moreover, we
observe that signaling mechanisms must operate externally to the Web \ac{pki}:
approaches such as Smart HTTPS or HSTS rely on certification within the Web
\ac{pki} for a client's first connection to a domain and thus are themselves
subject to stripping attacks. We therefore seek a solution that captures the set
of all \ac{https}-enabled domains, incurs minimal additional latency, is simple
to deploy, and is external to the Web \ac{pki}.

%Existing approaches to the signaling problem
%(\autoref{sec:background:signaling}) suffer from critical shortcomings. Some
%require domains to opt in using a process prone to misconfiguration, and render
%the domain inaccessible if misconfiguration occurs. Approaches that store
%deployment information locally only signal \ac{https} deployment in a subset of
%sites due to storage costs, and approaches that rely on external information
%incur significant latency penalties and introduce additional trusted parties.
%We therefore observe the need to address the signaling problem with a solution
%that allows clients to confidently distinguish a site that deploys \ac{https}
%without imposing performance penalties or trust assumptions.

To address the problem of moving towards a Web \ac{pki} more resilient to the
compromise of trusted parties, we thus tackle the certificate policy
specification and \ac{https} signaling problems. Our solution to these problems
is a system called \ac{name}, whic gradually increases the resilience of the Web
\ac{pki} against misbehaving \acp{ca}.

\ac{name} leverages Google's \ac{ct}~\cite{rfc6698} infrastructure
(\autoref{sec:background:ct}), which relies on \emph{public logs} that maintain
a database of all issued certificates in the Web \ac{pki}. We observe that these
databases can be used to signal the set of all domains that deploy \ac{https}.
By leveraging compression techniques and knowledge of domain name patterns and
trends, we can communicate a single bit indicating \ac{https} deployment for
each domain. Furthermore, domains who deploy \ac{https} can be automatically
detected, because their certificates will be included in these log databases.

Once a client can determine whether or not to expect a certificate policy
through the use of \ac{name}'s signaling mechanism, we can communicate simple
policies that require minimal domain involvement while preventing \ac{mitm}
attacks resulting from most cases of \ac{ca} misbehavior. In particular,
\ac{name} extends \ac{ct} logs to also maintain certificate policies. We can
achieve this by allowing domains to send multiple certificate chains for a
single public key during the \ac{tls} handshake, and then using certificate
policies to communicate to clients how many chains they should expect. This
approach allows logs to infer the policy's value based on the certificates that
are already logged in its database, and also prevents certificate misissuances
by individual misbehaving \ac{ca} from enabling \ac{mitm} attacks against these
domains.

%Because all certificates must be publicly logged to be accepted in Chrome
%browsers starting in October
%2017,\footnote{\url{https://cabforum.org/2016/10/19/2016-10-19-20-f2f-meeting-39-minutes/}}

In summary, this paper makes the following contributions:
\begin{compactitem}
\item It leverages \ac{ct} to propose a simple, deployable, and automated
  mechanism for maintaining and disseminating domain certificate policies.
\item It leverages finite state automata and data compression to present  a
  succinct design for communicating the set of sites deploying \ac{https}.
\item It evaluates \ac{name} against existing approaches and shows that
  \ac{name} outperforms these approaches, requiring only \steve{} extra
  communication, \steve{} additional storage, and \steve{} additional latency.
\end{compactitem}

%The Web \ac{pki} has seen several important improvements in recent years.
%\steve{Summary of CT, CAA, DANE, CAge, CRLite}

%Because \acp{ca} are trusted parties in the \ac{tls} \ac{pki}, they can enable
%\ac{mitm} attacks if they misbehave. Unfortunately, they have done so multiple
%times over the years, due to social engineering
%attacks~\cite{microsoft2001erroneous}, network breaches~\cite{comodo2011fraud,
  %hoogstraaten2012black}, operational errors~\cite{zusman2009sub,
  %langley2013enhancing, somogyi2015improved, sleevi2015sustaining}, or malicious
  %intent~\cite{percoco2012clarifying, langley2013further,
  %langley2015maintaining}. While in many cases the rogue certificates were
  %quickly detected and revoked, in some cases the certificates were actually
  %used in the wild in \ac{mitm} attacks~\cite{nightingale2011diginotar}. These
  %attacks are particularly noxious because the victim website may never find out
  %that it is being impersonated. Indeed, we have seen instances of targeted
  %attacks using fake certificates to impersonate websites to specific groups of
  %users~\cite{eckersley2011syrian}.

%While many attempts have been made to detect and prevent \ac{ca} misbehavior,
%one of the most widely-deployed fixes is \ac{ct}~\cite{rfc6962}. The goal of
%\ac{ct} is to enable fast and widespread detection of certificate issuance by
%publicly logging all certificates in \ac{tls}. A set of \emph{public logs}
%record all issued certificates in an append-only, tamper-proof fashion, and
%clients only accept a \ac{tls} certificate if it has been logged, thus forcing a
%potential adversary to publicize a certificate (making it detectable) before
%mounting a \ac{mitm} attack. However, simply adding logs to the existing
%\ac{tls} has several critical shortcomings. In particular, we identify three
%flaws with the current log-based architecture.


%a domain is associated with a policyin order to connect securely, a client needs
%to make sure that
%the policy was logged and registered (presence)
%the policy has not been updated since the value being read (recency)
%the policy was registered by the real domain (authenticity)

%what is the bad thing of having an incorrect policy?
  %accept too few certs or certs signed by the wrong ca (aka atker controlled)

%authenticated key-value store

