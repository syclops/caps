\section{Introduction}
\label{sec:intro}

%Some questions to think about:
%\begin{compactitem}
%\item How can we move toward a world in which domains use multiple independent
  %certificate chains?
%\item How do we validate a self-signed certificate?
%\item What does it mean to have trust agility?
%\item Does the use of multiple independent certificate chains provide better
  %security and agility?
%\end{compactitem}

\acs{https} is fundamental for secure Web communication. When a user Alice
wishes to securely access Bob's site \texttt{bob.com}, \ac{https} allows Bob to
serve his site over a secure communication channel that provides secrecy and
integrity. To establish this channel, Alice and Bob perform the \ac{tls}
handshake protocol~\cite{rfc5246}, which allows Bob to use his public key
$\pk_B$ to establish a shared secret key with Alice, which they can subsequently
use for encrypted communication.

To convince Alice that $\pk_B$ should be associated with \texttt{bob.com},
however, \ac{https} relies on the Web \ac{pki}. A trusted third party called a
\emph{\ac{ca}} checks that Bob owns both \texttt{bob.com} and $\pk_B$, and
issues a digitally signed certificate that vouches for this binding. \acp{ca}
thus play a crucial role in secure Web communication: the failure of any \ac{ca}
due to error, compromise, or coercion can lead to a certificate that binds
\texttt{bob.com} to a different public key $\pk_M$. If for example this key
belongs to an adversary Mallory, she can impersonate Bob to Alice in a
\emph{\ac{mitm} attack}, one of the main problems that \iac{pki} aims to solve.

Unfortunately, the current Web \ac{pki} is demonstrably fragile. Existing
certificate databases indicate that Web browsers and operating systems provided
by Mozilla, Apple, and Microsoft trust more than 1,500 \ac{ca} signing keys
across more than 600 organizations worldwide. There are few measures in place to
prevent any of these \acp{ca} from issuing an unauthorized certificate for any
site, resulting in \emph{weakest-link security} for most sites: the compromise
of any \ac{ca} can threaten the security of all Web domains, and by extension,
all clients visiting sites on those domains. Recent years have seen a plethora
of incidents where misbehaving \acp{ca} issued unauthorized certificates, both
accidentally~\cite{sleevi2015sustaining} and
intentionally~\cite{valsorda2015komodia}.

Previous work has been insufficient to make the Web \ac{pki} resilient to
certificate misissuances (see Section~\ref{sec:background} \steve{purposely
missing link because this version is just the intro}). Systems like
Google's \ac{ct} project~\cite{rfc6962} only allow for detection, not
prevention, of unauthorized certificate issuance. Systems that do prevent
unauthorized certificate issuance add new trusted
parties~\cite{kim2013accountable}, require domains to deploy complex new
infrastructure~\cite{rfc6698, szalachowski2014policert}, significantly increase
latency and communication~\cite{yu2016dtki}, or require all domains to increase
their security level at once~\cite{basin2014arpki}. Many of these systems also
require tens of millions of domains to put significant effort into creating
complex policies, hindering deployment.  In practice, for example, public-key
pinning~\cite{rfc7469} proved to be error-prone, contributing to its limited
deployment; as a result, Google recently decided to remove support for
it~\cite{palmer2017intent}.

To address these shortcomings, we propose \ac{name}, a system that provides a
modest roadmap to transition to a more resilient Web \ac{pki}. Specifically,
\ac{name} prevents clients from accepting unauthorized certificates issued by
individual misbehaving \acp{ca}, and allows this improvement to the Web \ac{pki}
to coexist with the current \ac{pki}. By enabling this overlap and by preventing
downgrade attacks (also called \emph{\ac{tls} stripping}), which prevent the
existing \ac{pki} from being used between a client and domain who both support
the improvement, \ac{name} allows domains to decide when they are ready to
deploy the \ac{pki} improvement.  \ac{name} does not penalize non-deployers and
provides stronger security guarantees to even the earliest adopters. The bulk of
the deployment effort of \ac{name} can occur at a small handful of participants,
namely browser vendors and public logs, who are better equipped to make these
changes than the millions of domains that currently deploy \ac{https}. Domains
do not need to change the way they interact with \acp{ca}, avoiding the perils
of misconfiguration that these domains have plagued previously proposed
improvements~\cite{palmer2017intent}.

\ac{name} achieves the above properties through several important observations.
First, because the Web \ac{pki} encompasses a vast set of domains with diverse
security needs, few changes to the \ac{pki} will be universally adopted
overnight. Thus we must have a \emph{signaling mechanism} to indicate which
domains have adopted a new \ac{pki} enhancement. Moreover, this signal must be
extrinsic to the \ac{pki} itself, since otherwise a client cannot distinguish a
non-deploying domain from an attacker attempting to subvert the connection
through a downgrade attack.

We further note that we can convey this extrinsic signal with the use of a
single bit that indicates whether a domain has deployed \ac{https}. Without this
bit \ac{tls} stripping can occur, causing the client to ignore even the existing
\ac{pki}, while with this bit, the remaining signaling information can be moved
into the \ac{tls} handshake as an extension. Because existing solutions for
indicating \ac{https} deployment require the client to trust its first
connection to the domain, they have lagged in deployment~\cite{rfc4033,
rfc6698}, and add significant storage
overhead\endnote{\url{https://www.eff.org/https-everywhere}} or connection
latency.\endnote{\url{https://mybrowseraddon.com/smart-https.html}} Instead, we
use data compression techniques and compact data structures to locally store at
each client a succinct summary of the \emph{entire} set of domains that deploy
\ac{https}; with our techniques, it requires just \steve{TODO}.

We also observe that all known instances of \ac{ca} misbehavior up to this point
have involved a single misbehaving \ac{ca}.  Hence, \ac{name} allows a domain to
authenticate its public key using multiple independent certificate chains (we
quantify the impact this has on connection latency and bandwidth in
Section~\ref{sec:eval:client} \steve{purposely missing link because this version
is just the intro}). \ac{name}-enabled clients know how many chains to expect
for each domain, and hence, the simultaneous failure of $n-1$ \acp{ca} cannot
enable \iac{mitm} attack on a domain with $n$ chains. Note that \ac{name}
signals to clients the \emph{number} of certificate chains to expect, rather
than the list of authorized \acp{ca}.  This results in a useful practical
property: misconfiguration or private key loss cannot render a domain
inaccessible, since the domain can simply obtain the requisite number of
certificates for a new public key, and revoke the old certificates through the
standard certificate revocation process (i.e., contacting the issuing \ac{ca}).

%Moreover, this process must prevent misconfiguration or private key loss from
%rendering a domain inaccessible as in existing systems for preventing \ac{mitm}
%attacks. We note that by having domains send multiple certificate chains
%authenticating a single public key and by enabling domains to simply
%communicate the number of chains a client should expect, we can protect domains
%from single misbehaving \acp{ca} and signal the deployment of a more resilient
%\ac{pki} without exposing domains to practical hazards. Domains can recover
%from misconfiguration or private key loss by simply obtaining certificates on a
%new public key.

To vouch for the number of certificate chains that a client should expect to
receive, \ac{name} uses a publicly auditable authenticated database service
based on a global view of all certificates in the Web \ac{pki}, which allows us
to \emph{automatically} infer the number of certificate chains for each domain.
In today's Web, we can obtain this global view through Google's \ac{ct}
system~\cite{rfc6962}, which is included in all Chrome browsers and as of April
2018 will be required for all \ac{https}-enabled sites that wish to be treated
as secure by Chrome~\cite{sleevi2016requiring}.

Finally, we observe that once we can establish a strongly authenticated,
authoritative public key for a domain, we can use this key to secure richer
policies as proposed in prior work~\cite{basin2014arpki,
szalachowski2014policert}. \ac{name} can thus simplify the policy authentication
mechanisms of these proposed systems, which rely on complex coordination among
domains, \acp{ca}, and public logs to certify these policies. \ac{name} also
enhances the recoverability of these systems, which, as originally proposed,
require waiting for days to replace a policy if the corresponding private key is
lost or compromised.

\ac{name} is also attractive from a deployment standpoint. In particular, the
administrative burden of deployment for domains is limited to purchasing
additional certificates, and with the use of free certificate services like
Let's Encrypt,\endnote{\url{https://letsencrypt.org/}} the financial burden can
be minimized as well. Furthermore, \ac{name} is an opt-in system, meaning that
only domains who choose to obtain additional certificates incur a cost. From its
initial deployment, \ac{name} protects all domains from \ac{tls} stripping, and
it allows non-deploying domains to coexist with deploying domains without
enabling downgrade attacks.

In summary, we make the following contributions:
\begin{compactitem}
%\item We conduct a study of the existing Web \ac{pki} to assess the current
  %state of \ac{https} among domains and the expected growth of \ac{https}
  %deployment.
\item We propose a design for \ac{name}, a system that enables the smooth
  bootstrapping of improvements to the Web \ac{pki}.
\item We leverage techniques from data compression and compact data structures
  to present a design for clients to locally store the entire set of
  \ac{https}-deploying domains on the Web.
\item We extend \ac{ct} logs to present a simple, deployable, and automated
  mechanism for maintaining and disseminating domain certificate policies.
% BP: Evaluation is how we validate the above.  It shouldn't typically be a separate contribution
%\item We evaluate \ac{name} against existing approaches and shows that
%  \ac{name} \steve{performs how relative to these approaches?}.
\end{compactitem}


%So far, proposed systems for communicating policy information to clients have
%not gained traction in practice. These systems introduce additional trusted
%parties~\cite{kim2013accountable} or assume that the entire Web will increase
%its security at once~\cite{basin2014arpki}. These shortcomings motivate the
%problem of designing a simple and deployable policy mechanism that requires
%minimal effort from domains. \steve{The last part isn't motivated well; it would
  %be nice if we could show that most policies are overkill for preventing
%\ac{mitm} attacks that could have resulted from recent \ac{ca} failures.}


%The Web's \ac{pki} enables client browsers to authenticate the public keys of
%the domains they communicate with, and together with the \ac{tls}
%protocol~\cite{rfc5246} allows a client and domain to establish an end-to-end
%secure communication channel through \acs{https}. In the Web \ac{pki},
%trusted third parties called \emph{\acp{ca}} vouch for the binding between a
%domain's name and its public key. The correct operation of \acp{ca} are critical
%to the security of the Web \ac{pki}, and failures can lead to the client
%establishing a secure channel with the wrong domain. In some cases this
%scenario can lead to a \emph{\ac{mitm} attack}, in which even though the
%confidentiality and integrity guarantees of communication over \ac{tls} hold,
%they provide no benefit because an adversary is impersonating the client and
%domain to each other and can read and modify all communication between them.

%While there are many proposals (enumerated in \autoref{sec:related}) to fix the
%Web \ac{pki} by deterring, preventing, or recovering from \ac{ca} misbehavior,
%Google's \emph{\ac{ct}} system~\cite{rfc6962} has recently emerged as a widely
%deployed example of such a system, being scheduled for full deployment in
%October 2017. \ac{ct} does not prevent \ac{mitm} attacks, but rather enables
%widespread detection of \ac{ca} misbehavior. In \ac{ct}, a set of \emph{public
%logs} maintain a database of certificates they have observed (primarily sent to
%them by the \acp{ca} themselves) and provide cryptographic proofs called
%\emph{\acp{sct}} that show when these certificates were submitted to the log.
%Clients do not accept certificates unless they are sent with a requisite number
%of these \acp{sct}, ensuring that an adversary cannot use an unauthorized
%certificate for \ac{mitm} attacks without first exposing that certificate to the
%world.

%However, \ac{ct} has several notable shortcomings. \ac{ct} does not make
%\ac{mitm} attack prevention an explicit goal, but specifies the behavior of
%\emph{monitors}, who periodically download newly logged certificates and check
%for suspicious certificates. However, only domains know which certificates they
%have authorized, and \ac{ct} does not allow domains to check logs for
%certificates issued in their name. This disparity means that some manual effort,
%on the part of the monitors, domains, or both, is required to prevent \ac{mitm}
%attacks that result from unauthorized certificates. Both monitors and domains
%face hurdles due to this manual effort.

%With the increasing deployment of \ac{https} through certificate services such
%as Let's Encrypt,\footnote{\texttt{https://letsencrypt.org/}} monitors may not
%be able to keep up with the number of suspicious certificates that require
%further manual investigation. Previous work enables domains to alleviate this
%pressure on monitors by explicitly supplying \emph{policies} that specify
%criteria that a domain's certificates should meet, but it is not clear that the
%expressiveness of these policies and the burden they impose on domain operators
%is worth the benefit of protecting them from common certificate misissuances. We
%therefore seek a simpler, more automated system for specifying certificate
%policies through the \ac{ct} infrastructure. In particular, we aim to move
%towards \iac{pki} in which one-off mistakes by \acp{ca} do not expose domains to
%\ac{mitm} attacks.

%Unfortunately, even with such policies, we still fall short of a truly secure
%\ac{pki}. Domains may not only have different policies, but some domains may not
%have policies at all because they do not deploy \ac{https}. Therefore, an
%adversary can carry out a \emph{\ac{tls} stripping} attack, in which the
%adversary convinces the client and domain to communicate over plain HTTP rather
%than over \ac{https}. Because we realistically expect a world of partial
%deployment in which the set of deploying domains increases incrementally over
%time, in order to prevent \ac{tls} stripping, we need a mechanism to inform
%clients \emph{when} to expect a certificate policy, not just \emph{what} policy
%to expect. We thus consider the following problem, which we call
%\emph{\ac{https} signaling}: how can we communicate to all clients the set of
%domains from which they should expect \iac{tls} certificate and certificate
%policy?

%Previous proposals (\autoref{sec:background:signaling}) have addressed this
%problem by requiring expensive online checks \steve{Smart HTTPS}, requiring
%domains to deploy DNSSEC~\cite{rfc6698}, or providing an incomplete view of the
%domains signaling \ac{https} deployment \steve{HTTPS Everywhere, HSTS
%preloading}. These approaches incur significant latency, are
%configuration-intensive and error-prone, or have limited scope. Moreover, we
%observe that signaling mechanisms must operate externally to the Web \ac{pki}:
%approaches such as Smart HTTPS or HSTS rely on certification within the Web
%\ac{pki} for a client's first connection to a domain and thus are themselves
%subject to stripping attacks. We therefore seek a solution that captures the set
%of all \ac{https}-enabled domains, incurs minimal additional latency, is simple
%to deploy, and is external to the Web \ac{pki}.

%%Existing approaches to the signaling problem
%%(\autoref{sec:background:signaling}) suffer from critical shortcomings. Some
%%require domains to opt in using a process prone to misconfiguration, and render
%%the domain inaccessible if misconfiguration occurs. Approaches that store
%%deployment information locally only signal \ac{https} deployment in a subset of
%%sites due to storage costs, and approaches that rely on external information
%%incur significant latency penalties and introduce additional trusted parties.
%%We therefore observe the need to address the signaling problem with a solution
%%that allows clients to confidently distinguish a site that deploys \ac{https}
%%without imposing performance penalties or trust assumptions.

%To address the problem of moving towards a Web \ac{pki} more resilient to the
%compromise of trusted parties, we thus tackle the certificate policy
%specification and \ac{https} signaling problems. Our solution to these problems
%is a system called \ac{name}, whic gradually increases the resilience of the Web
%\ac{pki} against misbehaving \acp{ca}.

%\ac{name} leverages Google's \ac{ct}~\cite{rfc6698} infrastructure
%(\autoref{sec:background:ct}), which relies on \emph{public logs} that maintain
%a database of all issued certificates in the Web \ac{pki}. We observe that these
%databases can be used to signal the set of all domains that deploy \ac{https}.
%By leveraging compression techniques and knowledge of domain name patterns and
%trends, we can communicate a single bit indicating \ac{https} deployment for
%each domain. Furthermore, domains who deploy \ac{https} can be automatically
%detected, because their certificates will be included in these log databases.

%Once a client can determine whether or not to expect a certificate policy
%through the use of \ac{name}'s signaling mechanism, we can communicate simple
%policies that require minimal domain involvement while preventing \ac{mitm}
%attacks resulting from most cases of \ac{ca} misbehavior. In particular,
%\ac{name} extends \ac{ct} logs to also maintain certificate policies. We can
%achieve this by allowing domains to send multiple certificate chains for a
%single public key during the \ac{tls} handshake, and then using certificate
%policies to communicate to clients how many chains they should expect. This
%approach allows logs to infer the policy's value based on the certificates that
%are already logged in its database, and also prevents certificate misissuances
%by individual misbehaving \ac{ca} from enabling \ac{mitm} attacks against these
%domains.

%Because all certificates must be publicly logged to be accepted in Chrome
%browsers starting in October
%2017,\footnote{\url{https://cabforum.org/2016/10/19/2016-10-19-20-f2f-meeting-39-minutes/}}

%The Web \ac{pki} has seen several important improvements in recent years.
%\steve{Summary of CT, CAA, DANE, CAge, CRLite}

%Because \acp{ca} are trusted parties in the \ac{tls} \ac{pki}, they can enable
%\ac{mitm} attacks if they misbehave. Unfortunately, they have done so multiple
%times over the years, due to social engineering
%attacks~\cite{microsoft2001erroneous}, network breaches~\cite{comodo2011fraud,
  %hoogstraaten2012black}, operational errors~\cite{zusman2009sub,
  %langley2013enhancing, somogyi2015improved, sleevi2015sustaining}, or malicious
  %intent~\cite{percoco2012clarifying, langley2013further,
  %langley2015maintaining}. While in many cases the rogue certificates were
  %quickly detected and revoked, in some cases the certificates were actually
  %used in the wild in \ac{mitm} attacks~\cite{nightingale2011diginotar}. These
  %attacks are particularly noxious because the victim website may never find out
  %that it is being impersonated. Indeed, we have seen instances of targeted
  %attacks using fake certificates to impersonate websites to specific groups of
  %users~\cite{eckersley2011syrian}.

%While many attempts have been made to detect and prevent \ac{ca} misbehavior,
%one of the most widely-deployed fixes is \ac{ct}~\cite{rfc6962}. The goal of
%\ac{ct} is to enable fast and widespread detection of certificate issuance by
%publicly logging all certificates in \ac{tls}. A set of \emph{public logs}
%record all issued certificates in an append-only, tamper-proof fashion, and
%clients only accept a \ac{tls} certificate if it has been logged, thus forcing a
%potential adversary to publicize a certificate (making it detectable) before
%mounting a \ac{mitm} attack. However, simply adding logs to the existing
%\ac{tls} has several critical shortcomings. In particular, we identify three
%flaws with the current log-based architecture.


%a domain is associated with a policyin order to connect securely, a client needs
%to make sure that
%the policy was logged and registered (presence)
%the policy has not been updated since the value being read (recency)
%the policy was registered by the real domain (authenticity)

%what is the bad thing of having an incorrect policy?
  %accept too few certs or certs signed by the wrong ca (aka atker controlled)

%authenticated key-value store

