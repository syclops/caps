\section{Security Analysis}
\label{sec:analysis}

In this section, we analyze the security that \ac{name} provides. We begin with
our main security claim and informally argue that it holds given our adversary
model. We then describe two potential weaknesses of \ac{name} not covered by our
security claim, and argue that countermeasures (some of which are currently
used) make these weaknesses difficult or impossible to exploit.


\subsection{Main Security Claim}
\label{sec:analysis:informal}

In making our main security claim, we assume that the client requests \numlas
policy proofs and that the domain has a domain name of \domain and a policy
value of \policy. 
%We assume that both the client and domain follow the handshake protocol as described. 
We also assume that our adversary controls $\numlas - 1$
private keys of log aggregators and the private keys of $\policy - 1$ \acp{ca}.
The adversary can also, of course, create its own public key pairs, e.g., 
$(\pk_\adversary, \pk_\adversary^{-1})$.
%and we assume that the adversary is the sole entity that controls the private
%key corresponding to a public key $\pk_\adversary$. 
We assume that the adversary
can intercept, suppress, replay, and modify any handshake message sent between
the client and domain, and can use its private keys to 
sign any message it can construct with the
information it obtains. We also assume that the adversary
cannot obtain a certificate binding \domain to $\pk_\adversary$ from any \ac{ca}
besides the ones it controls. Under these assumptions, we claim that a \ac{name}-enabled client
will abort the handshake protocol if it receives any certificate chain
containing $\pk_\adversary$ as the leaf public key. This claim 
supports the security of \ac{name} because to mount a successful MITM attack,
the adversary must convince the client to complete the \ac{name} handshake
based on a key that the adversary controls.

We first show that the adversary cannot convince the client that that the domain
has a policy value other than \policy. Because the client requests \numlas
policy proofs for \domain, the client will abort the handshake if the 
ServerHello message does not contain \numlas independent policy
proofs. Because we assume that the adversary only has access to $\numlas - 1$
log aggregator signing keys, the adversary cannot use those keys to
generate \numlas independent proofs. Specifically, if the adversary sends a set
of proofs and there are fewer than \numlas valid proofs, or if any of them fails
to prove that \policy is the policy value for \domain, then the client will
abort the handshake.

%Recall that the client determines \policy as the one plus the number of valid,
%independent certificate chains sent in the extension message. We show that the
%adversary cannot convince the client that the $\pk_\adversary$ is the domain's
%public key. From our assumption that the adversary can access the signing keys
%of $\policy - 1$ \acp{ca}, we know that the adversary controls \emph{at least}
%$\policy - 1$ private keys. 

From our assumption that the adversary can access the signing keys
of $\policy - 1$ \acp{ca},
we know that the number of \emph{independent} certificate chains that the adversary can generate
is \emph{at most} $\policy - 1$. It is straightforward to show this by induction
on \policy, with $\policy = 2$ as the base case.\footnote{Note that the $\policy
= 1$ case is equivalent to the current Web \ac{pki} (i.e., the domain only
provides a single certificate chain).} If the adversary generates $\policy - 1$
independent certificate chains for $\pk_\adversary$ and sends these chains to
the client, the client will validate the chains, but abort the handshake when
the $\policy^{th}$ independent chain fails to arrive. 

\subsection{Potential Weaknesses}
\label{sec:analysis:weaknesses}

Our main security claim shows that under our assumptions, the adversary cannot
mount a successful \ac{mitm} attack on a client and domain. Therefore, we can
conclude that the failure of $\numlas - 1$ log aggregators or $\policy - 1$ \acp{ca} 
are not sufficient to
enable a \ac{mitm} attack. However, we did not describe the consequence of
misbehavior by the other parties shown in \autoref{fig:overview}: the data
sources (namely, public logs) or the browser vendor. We now show that while
failures of these entities can have negative consequences for the performance or
security of \ac{name}, we consider these cases out of the scope of this work
because they are unlikely to succeed in practice or are catastrophic failures
that can circumvent almost any practical defense.

\paragraph{Resource Exhaustion}

Log aggregators rely on public logs to obtain a complete view of certificates in
the Web \ac{pki}. However, given the open nature of many of these logs (i.e.,
the fact that many parties can submit or otherwise make
certificates available to them), an adversary may take advantage of this
openness to force the log aggregators to increase their resource consumption.
For example, an adversary who controls \iac{ca} signing key can issue millions
of certificates and make them available to the logs, causing the log aggregators
to store these certificates when updating their respective policy databases.

While \ac{name} provides no mechanism to stop this behavior, the issuance of
these certificates produces traceable evidence of the adversary's behavior,
and the requirement that newly-issued certificates be logged increases the
likelihood of someone detecting this behavior. This detection would likely lead
to consequences such as the revocation of the \ac{ca} certificate by its issuing
\ac{ca} or by the browser vendor. Moreover, only an adversary with access to
\iac{ca} signing key can carry out this attack; while Let's Encrypt does provide
free certificates through an automatic protocol, it imposes a rate limit per
domain based on the Public Suffix
List,\footnote{\url{https://publicsuffix.org/}} thus requiring an adversary
without access to \iac{ca} signing key to obtain many domain names to carry out
this attack.

\paragraph{Malicious Browser Vendors}

Adversary control of the browser vendor is a catastrophic failure that can
enable a \ac{mitm} attack under almost any circumstances, since this allows the
adversary to completely control the client's experience with the Web. In this
scenario, the adversary can arbitrarily deviate from the \ac{tls} or \ac{name}
handshakes, insert its own root certificates, or display arbitrary pages. Even
with \ac{name}, an adversary-controlled vendor can also intercept and modify the
result of queries to the signaling set or rewrite HTTPS requests to HTTP
requests, defeating \ac{name}'s protection against downgrade attacks.
While some countermeasures such as OS-level protections may protect the client,
we suggest that defenses against PKI failures (whether \ac{name} or others)
are unlikely to stop powerful client-side adversaries.

\paragraph{Correlated CA Compromises}

Finally, our threat model assumes the adversary can compromise at most $\policy-1$
CAs. Historically, all publicly known CA failures have been singletons (i.e.,
separated in time and causation from other failures).  However, an adversary that discovered
a systemic flaw in all (or many) CAs could undermine the security of \ac{name}.
One mitigating factor is \ac{name}'s support for EV certificates,
which \ac{name} allows to dominate DV certificates (see Section~\ref{sec:design:overview}).
Hence, even in the event of a large multi-CA DV compromise,
a domain with (or able to obtain) an EV certificate would still be protected.
Since EV certificate issuance, unlike DV issuance, requires manual steps,
we may hope that CA failures around EV certificates are less likely to be correlated.
