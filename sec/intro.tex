\section{Introduction}
\label{sec:intro}

%Some questions to think about:
%\begin{compactitem}
%\item How can we move toward a world in which domains use multiple independent
  %certificate chains?
%\item How do we validate a self-signed certificate?
%\item What does it mean to have trust agility?
%\item Does the use of multiple independent certificate chains provide better
  %security and agility?
%\end{compactitem}

The Web's \ac{pki} enables client browsers to authenticate the public keys of
the domains they communicate with, and together with the \ac{tls}
protocol~\cite{rfc5246} allows a client and domiain to establish an end-to-end
confidential communication channel. In the Web \ac{pki}, trusted third parties
called \emph{\acp{ca}} vouch for the binding between a domain's name and its
public key. The correct operation of \acp{ca} are critical to the security of
the Web \ac{pki}, and failures can lead to the client establishing a
confidential channel with the wrong domain. In some cases this scenario can lead
to a \emph{\ac{mitm} attack}, in which even though the confidentiality and
integrity guarantees of communication over \ac{tls} hold, they provide little
benefit because the client and domain are in fact communicating with an
adversary who is impersonating each to the other and can read and modify all
client-domain communication.

The Web \ac{pki} has seen several important improvements in recent years.
\steve{Summary of CT, CAA, DANE, CAge, CRLite}

However, two important problems remain. The first is the \emph{signaling}
problem, that is, how a domain securely communicates to a client that the client
should expect to connect over HTTPS. Without a proper signaling mechanism, an
adversary can attempt to convince a client that the domain does not deploy
HTTPS,

signaling problem and scoping problem remain


Because \acp{ca} are trusted parties in the \ac{tls} \ac{pki}, they can enable
\ac{mitm} attacks if they misbehave. Unfortunately, they have done so multiple
times over the years, due to social engineering
attacks~\cite{microsoft2001erroneous}, network breaches~\cite{comodo2011fraud,
  hoogstraaten2012black}, operational errors~\cite{zusman2009sub,
  langley2013enhancing, somogyi2015improved, sleevi2015sustaining}, or malicious
  intent~\cite{percoco2012clarifying, langley2013further,
  langley2015maintaining}. While in many cases the rogue certificates were
  quickly detected and revoked, in some cases the certificates were actually
  used in the wild in \ac{mitm} attacks~\cite{nightingale2011diginotar}. These
  attacks are particularly noxious because the victim website may never find out
  that it is being impersonated. Indeed, we have seen instances of targeted
  attacks using fake certificates to impersonate websites to specific groups of
  users~\cite{eckersley2011syrian}.

While many attempts have been made to detect and prevent \ac{ca} misbehavior,
one of the most widely-deployed fixes is \ac{ct}~\cite{rfc6962}. The goal of
\ac{ct} is to enable fast and widespread detection of certificate issuance by
publicly logging all certificates in \ac{tls}. A set of \emph{public logs}
record all issued certificates in an append-only, tamper-proof fashion, and
clients only accept a \ac{tls} certificate if it has been logged, thus forcing a
potential adversary to publicize a certificate (making it detectable) before
mounting a \ac{mitm} attack. However, simply adding logs to the existing
\ac{tls} has several critical shortcomings. In particular, we identify three
flaws with the current log-based architecture.


a domain is associated with a policyin order to connect securely, a client needs
to make sure that
the policy was logged and registered (presence)
the policy has not been updated since the value being read (recency)
the policy was registered by the real domain (authenticity)

what is the bad thing of having an incorrect policy?
  accept too few certs or certs signed by the wrong ca (aka atker controlled)

authenticated key-value store

